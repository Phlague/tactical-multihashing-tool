# tactical-multihashing-tool
{   "topic":"A-Little-Bit-About-Hashes", }, {   "hash-example":'32c0ced56f1fe08583bdb079d85a35a81995018c', }, {   "detail":"Hackers often steal entire databases of user login and password data, and because of this, hashes are the preferred way to store sensitive information like passwords.  Hashes are different from encryption because they do not store data. Instead, the number that makes up a hash is the result of a calculation run on whatever it is you're hashing, be it a password or an entire file. This is used to ensure that the file you are downloading matches the file you're intending to download or to confirm the password the user entered matches the password they signed up with.  Depending on the size of the file or password you're hashing, hashes like SHA-1 or MD5 will take fixed blocks of the data you're hashing and run a complex calculation on it block by block until it reaches a final value. This value is a very long number designed to be unique so that one can verify that one file matches another by comparing the hash values. If the hash value is different, then something about the file has been changed.  This is great because if the user enters any password other than the one they chose, the hash value will be completely different. Because of this, the developer just needs to store the hash, because any time the user needs to log in, they can just enter the password to create a new hash to compare to the stored one.  As an example, I hashed nullbyte to the following SHA-1 value. You can create your own SHA-1 hash at sha1-online.com to see for yourself what this looks like.", }, {   "One-Problem-with-SHA-1-Hashes":"Unfortunately for developers, not all hashes are created equal for storing passwords. For hashes like SHA-1, there are a few problems that make saving passwords with SHA-1 a less-than-ideal solution.  To highlight one, every time you hash the same word with SHA-1, it generates the exact same hash. While this is by design, you can simply take a huge number of guesses and hash them all into SHA-1, and then compare the hashes rapidly to get the password the SHA-1 hash was derived from. Because SHA-1 is designed to be fast, this process takes a very short amount of time, which makes it even easier to brute-force.  There are some solutions to this, and one of the most popular is adding a salt. A salt is a string of text that you can add to the password before hashing it. An example would be to add the word salt to the password nullbyte. While we know the SHA-1 value of nullbyte from above, the hash of nullbytesalt or saltnullbyte would be totally different. This helps, but if the salt is not per user, then figuring out the salt is not too difficult and you're back to the same problem.", }, {   "How-Bcrypt-Can-Help-Make-Hashes-More-Secure":"A better solution is to add a random salt, and there is a hashing algorithm that was created for storing passwords with exactly this in mind.  Bcrypt is not only deliberately slow to foil brute-forcing, it also adds a random salt to each hash it generates. As a result, no two bcrypt hashes will be the same, even if they're made from the exact same password. To check a guess against a bcrypt hash, you instead have to use a bcrypt function that takes the password guess and the hash as an argument and returns the result of whether or not they match.  To show off how these different hashes work, I wrote some Python to turn any password into a SHA-1, MD5, and bcrypt hash.", },
